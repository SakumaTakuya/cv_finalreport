\section{実装詳細}
問題の全体像を以下の図に示す。まず、図\ref{}(a)の部分画像ABCD(テンプレート画像)とマッチする部分画像EFGH(適用画像)を図中(c)から探索する。その後図中(b)の差し替え先画像から差し替え画像へのホモグラフィ行列を計算し、ワーピング処理によって差し替えを行う。

本レポートでは頂点ABCDの選定は手動で行うが、頂点EFGHは明示的に選択せず、特徴量マッチングによって暗黙的に行う。この場合、差し替え先画像から適用画像へのホモグラフィ行列は、各ピクセルの対応が分からないため、直接求めることはできない。そこで、テンプレート画像と差し替え先画像の画像サイズを一致させてから、テンプレート画像と適用画像との特徴量マッチングを行うことで、ここから求められるテンプレート画像から適用画像へのホモグラフィ行列が差し替え先画像から適用画像へのホモグラフィ行列に一致する。
このようにして各ピクセルの変換方法が求められるため画像を置換できる。

本章では、各操作の詳細アルゴリズム及び実装を述べる。

\subsection{実行環境}
本レポートは次の実行環境で動作させている。
\begin{itemize}
    \item Python 3.7
    \item kivy 1.11.1
    \item OpenCV-python 3.4.2.16
    \item Numpy 1.19.0
\end{itemize}



\subsection{テンプレート画像と差し替え先画像の画像サイズ}
本問題では図\ref{}(a)の頂点ABCDには任意性があるため、単純なリサイズ処理ではテンプレート画像と差し替え先画像のサイズを一致させることができない。
本レポートではワーピング処理によって頂点ABCDを矩形に変換する。
変換によって画像にピクセルの抜けが生じないようにするためInverse warpingを実装する。
具体的には以下の図\ref{}に示す、
四角形MNOP内の任意の点$(x_1, y_1)$から四角形IJKLの対応する点$(x_0, y_0)$を求める。
$(x_1, y_1)$から辺MNへの距離及び垂線の足をそれぞれ$d_MN$及び$\bm{}$


ワーピング処理の具体的な実装は以下のプログラム\ref{}に示す。




なお、一致させる画像サイズの決め方は次の二種類の方法が考えられる。
\begin{itemize}
    \item 差し替え先画像の高さ・幅に合わせる
    \item テンプレート画像の高さ・幅に合わせる
\end{itemize}
前者については、差し替え先画像は必ず長方形の形をしているため、簡単に高さや幅を取得することができる。


\subsection{マッチングアルゴリズム}
マッチングアルゴリズムには様々な手法が提案されているが、
本レポートではテンプレートマッチング及び特徴点マッチングをそれぞれ使用した。

\subsubsection{テンプレートマッチング}
テンプレートマッチングは画像の画素値そのものを特徴として扱うパターンマッチングの一種である\ref{}。
この手法では特徴となる画素値をテンプレートとして用意しておき、SSDを始めとする類似度を使用してマッチングを行う\ref{}。

本問題においても予めテンプレート画像は用意しておくが、
サイズが大きいため、精度が低下してしまうことが予想される。
さらに根本的な問題として、テンプレートマッチングでは各ピクセルの対応が取れるわけではなく、
一致する領域が得られるに過ぎないため、本問題の目的には合致しない。

そこで、本レポートではハリスのコーナー検出\ref{}を利用して特徴点を検出した後、
その点を中心とした部分画像をテンプレートとしてマッチングを行う。

